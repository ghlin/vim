snippet if "if ... then ... else ..."
if ${1:condition}
   then ${2:expression}
   else ${3:expression}
endsnippet

snippet case "case ... of ..."
case ${1:expression} of
     ${2:pattern} -> ${3:expression}
     ${4:pattern} -> ${5:expression}
endsnippet

snippet => "Type constraint"
(${1:Class} ${2:Type var}) => ${3:$2}
endsnippet

snippet def "Function definition"
${1:name} :: ${2:Type} -> ${3:Type}
endsnippet

snippet | "Guard"
| ${1:predicate} = ${2:undefined}
endsnippet

snippet \ "Lambda expression"
\\${1:pattern} -> ${2:expression}
endsnippet

snippet let "let ... in ..."
let ${1:name} = ${2:expression}
 in $0
endsnippet

snippet ! "useful language pragmas" !b
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE TupleSections #-}
endsnippet

snippet # "pragma" !b
{-# ${1:LANGUAGE} #-}
endsnippet

snippet lang "language pragma" !b
{-# LANGUAGE $0 #-}
endsnippet

snippet qqs "language pragma: quasiquotes" !b
{-# LANGUAGE QuasiQuotes #-}
endsnippet

snippet derif "language pragma: DeriveFunctor" !b
{-# LANGUAGE DeriveFunctor #-}
endsnippet

snippet lamc "language pragma: LambdaCase" !b
{-# LANGUAGE LambdaCase #-}
endsnippet

snippet tmphs "language pragma: TemplateHaskell" !b
{-# LANGUAGE TemplateHaskell #-}
endsnippet

snippet tupls "language pragma: TupleSections" !b
{-# LANGUAGE TupleSections #-}
endsnippet

snippet multif "language pragma: MultiwayIf" !b
{-# LANGUAGE MultiWayIf #-}
endsnippet

snippet cpp "language pragma: CPP" !b
{-# LANGUAGE CPP #-}
endsnippet

snippet import "import ...." !b
import             ${1:Package}              ${2:for}
endsnippet

snippet importq "qualified import..." !b
import qualified   ${1:Package}             as ${2:as}
endsnippet
